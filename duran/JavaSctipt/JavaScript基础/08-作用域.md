# 作用域（scope）

作用域是一套规则，它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

作用域指一个变量的作用范围。在js中，一共有两种作用域：

- 全局作用域

- 函数作用域

## 全局作用域

直接编写在script标签中的JS代码，都在全局作用域。

是最大的作用域。

- 全局作用域在页面打开时创建，在页面关闭时销毁。

- 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。

在全局作用域中：

- 创建的**变量**都会作为window对象的属性保存。

- 创建的**函数**都会作为window对象的方法保存。

全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到。

### 变量提升

使用var关键字声明的变量，例： `var a = 8`），**会在所有的代码执行之前被声明**，但是不会赋值，但是声明变量时不是用var关键字直接写`a = 8`，则变量不会被声明提前。

### 函数声明提前

函数声明：

使用`函数声明`的形式创建的函数`function fn(){}`，**会被声明提前**。

也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。

函数表达式：

使用函数表达式创建的函数`var fn = function(){}`，**不会被声明提前**，所以不能在声明前调用。

fn被声明了，且为undefined，并没有把 `function(){}` 赋值给 fn。

## 局部作用域

局部作用域就是在全局作用域下面，开辟出来的一个相对小一些的作用域。在 js 中只有函数能生成一个局部作用域，别的不行， 在局部作用域中定义的变量只能在这个局部作用域内部使用

- 调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁
- 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的

```js
var num = 100;
console.log(num1);//num1 is not defined
function fn(){
    var num1 = 200;
    console.log(num1);//200
    console.log(num);//100
}
fn()
```

## 函数作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)

## 块级作用域

块级作用域就是包含在语法 { } 中的作用域。

块级作用域只对 let 和 const 声明有效，对 var 声明无效。

try/catch
let / const

在 ES6 中引入了 let 关键字，用来在任意代码块中声明变量。

从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）。

## 作用域链

有了作用域以后，变量就有了使用范围，也就有了使用规则

当代码试图访问一个变量的时候，解释器将在当前的作用域对象中查找这个属性。如果这个属性不存在，那么解释器就会在父作用域对象中查找 这个属性。就这样，一直向父作用域对象查找，直到找到该属性或者再也没有父作用域对象。我们将这个查找变量的过程中所经过的作用域对象称作作用域链 （Scope chain）

执行顺序：

- 首先，在自己的作用域内部查找，如果有，就直接拿来使用
- 如果没有，就去上一级作用域查找，如果有，就拿来用
- 如果没有，就进行去上一级作用域查找，以此类推
- 如果一直到全局作用域 window 都没有这个变量，那么就会直接报错（该变量 is not defined）

在函数作用域也有声明提前的特性：

- 使用var关键字声明的变量，会在函数中所有的代码执行之前被声明

- 函数声明也会在函数中所有的代码执行之前执行

因此，在函数中，没有var声明的变量都是**全局变量**，而且并不会提前声明。

## 作用域预解析

### 全局预解析

- 会在页面打开的时候就进行了

- 只解析属于全局的内容

```js
var a = 100;// 会被解析
function fn(){// 会被解析
    var b = 200;// 不会被解析
}
```

### 局部解析

- 当函数执行的时候进行预解析

- 函数内部的预解析，只属于函数内部

```js
var a = 100;// 会被解析
function fn(){// 会被解析
    var b = 200;// 等函数执行后，才会被解析
}
fn();// 此时函数执行了，开始解析函数内部
```
