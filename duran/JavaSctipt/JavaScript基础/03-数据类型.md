# 数据类型

- 基本数据类型
  - Number
  - String
  - Boolean
  - underfined
  - Null
- 引用数据类型
  - Object

## Number

- 包含
  - 常规数字包括整数和浮点数(小数)
  - NaN
    - 不是一个数字，但是属于数字类型
    - NaN和任何数值(包括自己都不相等)
- 最大值最小值
  - 最大值   **Number.MAX_VALUE** 
  - 最小值   **Number.MIN_VALUE** 
  - 若number表示的数字超过了最大值则会返回一个Infinity(正无穷大)
- isNaN  可以检查一个值是否为有效数字，有效数字返回false，反之返回true。
  - 在使用isNaN 进行检测的时候，首先会验证检测的值是否是数字类型，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测。
- 其他类型转换为Number
  - 字符串转换为数字类型
    - 只要字符串中包含有任意一个**非有效数字字符**(第一个点除外)，结果都是NaN。
    - 空字符串会变为数字零。
    - Number(纯数字的字符串)，进行转换。
  - 布尔转换为数字类型
    - true 转换为 1
    - false 转换为 0
  - Null转换为数字类型
    - null转换为 0
  - undefined 转换为数字类型
    - undefined 转换为 NaN
  - 引用数据类型转换为数字，是先把他基于toString方法转换为字符串，然后在转换为数字。
- parseInt/parseFloat([val],[进制])
  - 也是转换为数字的方法，对于字符串来说，他是从左到右一次查找有效数字字符，直到遇到非有效数字字符，停止查找(不管后面是否还有数字，不在查找)，把找到的当作数字返回。
  - parseInt（）把一个字符串中有效的整数内容转化为一个整数。
  - parseFloat（）把一个字符串转化为一个小数。作用：获得有效的小数。
- ==  在进行相等判断的时候也会转换为数字

## String

- 所有用单引号、双引号、反引号包起来的都是字符串

- 其他类型转换为字符串

  - [val].toString()
  - 字符串拼接
    - 四则运算法则中，除加法之外，其余都是数学计算，只有加法可能存在字符串拼接(一旦遇到字符串，不是数学运算，就是字符串拼接)。这是隐式的类型转换，由浏览器自动完成，实际上也是调用string()函数
  - null和undefined禁止直接转换为toString，调用会报错
  - 普通对象.toString()的结果是

  ```javascript
  "[object Object]"=>Objcet.prototype.toString方法不是转换为字符串的，而是用来检测数据类型的
  ```

  - String（）
    - 使用String（）函数做强制转换时对于number 和Boolean 实际上就是调用tostring（）方法。
    - 但是对于null和undefined就不会调用tostring（）方法，它会将null直接转换为"null",将undefined转换为"undefined"

## Boolean

- 只有两个值   true/false

- 其他类型转换为布尔类型

  - 只有 0 、NaN、'' 、null 、undefined 五个之转换为false，其余转换为true(没有特殊情况)
  - Boolean([val])

  ```js
  console.log(Boolean(-1));  =>true
  ```

  - !/!!
    - ! ：取反(先转换为布尔，然后取反)
    - !!:   取反在取反，只相当于转换为布尔(先转换为布尔，然后取反，在取反)
  - 条件判断
    - 若条件只是一个值，不是==/===/！=/>=，是要转为布尔类型，然后验证真假

## null和undefined

都代表的是没有

- null ：意料之中(一般都是开始不知道值，手动设置为null，后期在赋值)；
  - 一般用null作为初始空值，因为零不是空值，在栈内存中有一定的储存空间
- undefined ：意料之外  (不是你所能决定的)
  - 创建一个变量没有赋值，默认值是undefined 

## Object

- {[key]:[value],.......}  任何一个对象都是由零到多组键值对（属性名：属性值）组成的，并且属性名不能重复 
- 分类
  - 内建对象
  - 宿主对象
  - 自定义对象
- 属性
  - 设置属性名属性值
    - 属性名不能重复，如果属性名已经存在，不属于新增属于修改属性值
  - 获取属性名对应的属性值
    - 对象 . 属性名
    - 对象[属性名]
    - 若属性名不存在，默认值的属性值是undefined  
    - 如果属性名是数字，则不能使用点的方式获取属性值
  - 添加属性
    - 对象 . 属性名=属性值
  - 删除属性
    - 真删除 ： 把属性彻底删掉 delete +属性名
    - 假删除 ： 属性还在值为空；值设置为null

### Array

数组是一个单个对象，包含很多值，用方括号[]括起来，逗号分隔。

- 数组是特殊的对象数据类型
  - 中括号中设置的是属性值，属性名是默认生成的数字。
  - 默认属性length，存储数组的长度
  - 最后一项的索引是  数组长度-1
- 方法
  - push()
    - 该方法可以向数组的末尾添加一个或多个元素并返回新的数组长度
    - 将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾
  - pop()
    - 该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回
  - unshift()
    - 向数组开头添加一个或多个元素并返回新的数组长度
    - 插入元素后，其他元素会以此调整
  - shift()
    - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回

## 数据类型的存储

* 基本数据类型直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响另一个变量 ；
* 引用数据类型，引用数据类型是直接保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象的引用，当通过一个变量修改属性时，另一个也会收到影响。
* 当我们比较两个基本数据类型时，我们比较的是两个数值，当我们比较两个引用数据类型，比较的是两个内存地址；
* JS中的变量都是保存在栈内存中的 ；

## 数据类型的检测

- `type of[val]` : 用来检测数据类型的运算符
  - 基于`type of`检测出来的结果
    - 首先是一个字符串
    - 字符串中包含对应的类型
  - 局限性
    - `type of null => "object"` 但是`null`并不是对象
    - 基于`type of`无法细分出当前值是普通对象还是数组对象等，因为只要是对象数据类型，返回的结果都是"object"
- `instanceof：` 用来检测当前实例是否隶属于某个类
- `constructor ：` 基于构造函数检测数据类型
- `Object.prototype.toString.call() :`检测数据类型最适合的方法
