# 函数

- 可以在一个代码块中存储一段用于处理单任务的代码，然后用一个简短的命令来调用。
- 就是将一些功能或者语句进行封装，通过调用的形式，执行这些语句
- 函数也是一个对象。

**函数的作用**：

- 将大量重复的语句写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。

- 简化编程，让编程模块化。

## 函数的定义和调用

### 函数的定义

函数声明：

使用函数声明创建一个函数。语法：

```js
function 函数名([形参1,形参2...形参N]){ 
     // 备注：语法中的中括号，表示“可选”
    语句...
}
```

举例：

```js
function sum(a,b,c){
    return a+b+c;
}
```

解释如下：

- function：是一个关键字。中文是“函数”、“功能”。

- 函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。

- 参数：可选。

- 大括号里面，是这个函数的语句。

函数表达式：
使用函数表达式来创建一个函数。语法：

```js
var 函数名  = function([形参1,形参2...形参N]){
     语句....
    }
```

举例：

```js
var sum = function () {
    alert("hello world")
}
```

函数表达式就是将一个匿名函数赋值给一个变量

### 函数调用

定义函数并不会自动执行，调用函数才会给参数真正执行这些动作。

语法：`函数名字()`

## 函数的形参和实参

**形参：**

- 可以在函数的`()`中来指定一个或多个形参。

- 多个形参之间使用`,`隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

**实参**：

- 在调用函数时，可以在 `()`中指定实参。

- 实参将会赋值给函数中对应的形参。

```js
function sum (a,b){
    console.log(a+b);
}//a、b就是形参
sum(3,4);
sum("hello","world")//为实参，真实的数值、字符串
```

**实参的类型：**

函数的实参可以是任意的数据类型。

调用函数时解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。

**实参的数量：**

调用函数时，解析器也不会检查实参的数量：

- 多余实参不会被赋值

- 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined。

## 函数的返回值

return的作用是结束方法。

注意：

- return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。

- 在函数中return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出）

- 如果return语句后不跟任何值，就相当于返回一个undefined

- 如果函数中不写return，则也会返回undefined

- 返回值可以是任意的数据类型，可以是对象，也可以是函数。

```js
function sum (a,b){
    return a + b;
}
```

## 立即执行函数

匿名函数如下：

```js
function(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
};
```

立即执行函数如下：

```js
(function(a, b) {
    console.log("a = " + a);
    console.log("b = " + b);
})(123, 456);
```

立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。

立即执行函数只会执行一次，没有保存变量，执行完以后就找不到了。

## 方法

函数也可以称为对象的属性。**如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法**。

调用这个函数就说调用对象的方法（method）。相比于方法，它只是名称上的区别，并没有其他的区别。

举例：

```js
函数举例
fn()//调用函数

方法举例
obj.fn()//调用方法
```

可以这样说，若直接是`fn()`，那就说明是函数调用。若是发现`XX.fn()`的这种形式，那就说明是**方法**调用。

## 函数提升

```js
console.log(sum(3,4))//7
function sum (a,b){
    return a + b
}
```

sum() 函数在声明之前被调用，但此代码的运行并没有任何错误。这是因为 JavaScript 解释器会将整个函数声明提升到当前作用域的顶部。上面代码等同于

```js
function sum (a,b){
    return a + b
}
console.log(sum(3,4))//7
```

函数提升仅适用于函数声明，而不适用于函数表达式。

## 函数名、函数体和函数加载问题  重要

请谨记： 函数名 == 整个函数

当调用一个函数时，通常使用`函数()`这种格式；但是直接使用`函数`这种格式，它的作用相当于整个函数。

**函数的加载问题**：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。

```js
function sum(a){
    return a;
}
console.log(fn) == console.log(function sum(a){return a;})
```

### fn()  和 fn 的区别

- `fn()`：调用函数。相当于获取了函数的返回值。

- `fn`：函数对象。相当于直接获取了函数对象。

## 函数作用域

在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的作用域内定义。一个函数可以访问定义在其范围内的任何变量和函数。

也就是说定义在全局域中的函数可以访问所有定义在全局域中的变量。定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量。

```js
//下面变量定义在全局作用域中
const num1 = 2;
const num2 = 6;
function sum(){
    return num1+num2;
}
console.log(sum());//8
function getScore() {
  const num1 = 3;
  const num2 = 2;

  function add() {
    return `${name} 的得分为 ${num1 + num2}`;
  }/* ${name} 表示在该位置插入 name 变量的值。
${num1 + num2} 表示在该位置插入 num1 和 num2 变量相加的结果。 */

  return add();
}

console.log(getScore()); //结果为5
```

## 使用 arguments 对象

arguments 对象是所有（非箭头）函数中都可用的局部变量。可以使用arguments 对象在函数中引用函数的参数。

函数的实际参数会被保存在一个类似数组的 arguments 对象中。可按照如下方式找出参数：`arguments[i];`

其中 i 是参数的序号，从 0 开始。所以第一个传入函数的参数会是 arguments[0]。参数的数量由 arguments.length 表示。

使用 arguments 对象，可以处理比声明更多的参数来调用函数.

事先不知道会需要将多少参数传递给函数时十分有用。可以用 arguments.length 来获得实际传递给函数的参数的数量，然后用 arguments 对象来访问每个参数。

arguments 转数组

通常使用下面的方法来将 arguments 转换成数组：

`Array.prototype.slice.call(arguments);`
还有一个更简短的写法：

`[].slice.call(arguments);`
在这里，只是简单地调用了空数组的 slice 方法，而没有从 Array 的原型层面调用。

slice 方法得到的结果是一个数组，参数便是 arguments。事实上，满足一定条件的对象都能被 slice 方法转换成数组。

## 函数参数

两种特殊的参数语法：默认参数和剩余参数。

### 默认参数

函数默认参数允许在没有值或 undefined 被传入时使用默认形参。

在 JavaScript 中，函数参数的默认值是 undefined。在某些情况下设置不同的默认值可能会很有用，这是默认参数的作用。

```js
function sum(a, b) {
  return a * b;
}

sum(5, 2); // 10
sum(5); //NaN
为了防止这种情况可以采用以下代码进行改进
function sum(a, b) {
    b = type of b !== "undefined" ? b : 1;
    //此代码先检查b类型是否等于字符串undefined，并运用三元运算符，最后将结果赋值给b
    return a * b;
}

sum(5, 2); // 10
sum(5); //5
```

### 剩余参数

剩余参数语法允许将不确定数量的参数表示为数组。

语法：

```js
function(a, b, ...theArgs) {
  // ...
}
```

如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。

theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数.

剩余参数和 arguments对象的区别

剩余参数和 arguments对象之间的区别主要有三个：

- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
- arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
- arguments对象还有一些附加的属性（如callee属性）。
